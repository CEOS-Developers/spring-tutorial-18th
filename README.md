# CEOS 18th Backend Study - 1주차 미션
스프링 어노테이션을 심층 분석해요
- 어노테이션이란 무엇이며, Java에서 어떻게 구현될까요?
- 스프링에서 어노테이션을 통해 Bean을 등록할 때, 어떤 일련의 과정이 일어나는지 탐구해보세요.
- `@ComponentScan` 과 같은 어노테이션을 사용하여 스프링이 컴포넌트를 어떻게 탐색하고 찾는지의 과정을 깊게 파헤쳐보세요.

단위 테스트와 통합 테스트 탐구
- 단위 테스트와 통합 테스트의 의미를 알아봅시다!
- 스터디 자료의 단위 테스트 예제는 엄밀한 의미의 단위 테스트라고 부를 수 있을까요?
- 아니라면 엄밀한 의미의 단위 테스트로 구현하기 위해 어떻게 바꾸어야 할지 생각해 보아요.

## 스프링 어노테이션 심층 분석

### 어노테이션이란 무엇이며, Java에서 어떻게 구현될까요?
어노테이션이란, 프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것이다. 
어노테이션은 주석처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공할 수 있다.
다음은 @Test 어노테이션을 활용한 코드의 일부이다.

```java
@Test
public void method() {
    ...
}
```

이때, @Test 어노테이션은 하위 메서드를 테스트해야 한다는 것을 알리는 역할을 할 뿐, 메서드가 포함된 프로그램 자체에는 아무런 영향을 미치지 않는다.

Java에서 어노테이션을 구현하는 방법은 아래와 같다. 

```java
@interface 어노테이션이름 {
    타입 요소이름(); // 어노테이션의 요소를 선언
    ...
}
```

@ 기호를 붙이는 것을 제외하면 인터페이스를 정의하는 것과 동일하며, 어노테이션 내에 선언된 메서드를 어노테이션의 요소라고 한다. 어노테이션의 적용 시 모든 요소들의 값을 지정해주어야 하는데, 각 요소는 기본값을 가질 수 있어 값을 지정하지 않으면 기본값이 사용된다.

어노테이션의 요소를 선언할 때 반드시 지켜야 하는 규칙은 다음과 같다.
- 요소의 타입은 기본형, String, enum, 어노테이션, Class만 허용된다
- () 안에 매개변수를 선언할 수 없다
- 예외를 선언할 수 없다
- 요소를 타입 매개변수로 정의할 수 없다

다음은 잘못된 어노테이션 요소 선언의 예시이다.

```java
@interface AnnoTest {
    String major(int i, int j); // () 안에 매개변수 선언할 수 없음
    String minor() throws Exception; // 예외 선언할 수 없음
    ArrayList<T> list(); // 요소의 타입에 타입 매개변수 사용불가
}
```

### 스프링에서 어노테이션을 통해 Bean을 등록할 때, 어떤 일련의 과정이 일어나는지 탐구해보세요.
#### @Bean 사용

스프링 컨테이너는 @Configuration이 붙은 클래스를 설정 정보로 사용한다. 여기서 @Bean이 붙은 메서드를 모두 호출하고, 반환된 객체를 스프링 컨테이너에 등록한다.
이때, 등록되는 스프링 빈은 따로 지정하지 않았다면 메서드의 이름을 스프링 빈의 이름으로 사용하여 key로 삼고, bean 객체를 value로 삼는다.

#### @ComponentScan 사용

@ComponentScan을 사용하면 @Component 어노테이션이 붙은 모든 클래스를 스캔해서 스프링 빈으로 등록한다.
이때, 등록되는 스프링 빈은 따로 지정하지 않았다면 클래스의 이름을 스프링 빈의 이름으로 사용하여 key로 삼고, bean 객체를 value로 삼는다.

### `@ComponentScan` 과 같은 어노테이션을 사용하여 스프링이 컴포넌트를 어떻게 탐색하고 찾는지의 과정을 깊게 파헤쳐보세요.
@ComponentScan 어노테이션 사용 시, basePackages 값 설정을 통해 탐색할 패키지의 시작 위치를 지정하거나 basePackageClasses 값 설정을 통해 지정한 클래스의 패키지를 탐색 시작 위치로 지정할 수 있다. 탐색할 패키지의 시작 위치를 지정하면 그 패키지를 포함한 하위 패키지를 모두 탐색한다.

컴포넌트 스캔 기본 대상은 다음과 같다.
- @Component
- @Controller
- @Service
- @Repository
- @Configuration

필터를 통해 컴포넌트 스캔 대상을 추가하거나 제외할 수도 있다.
- includeFilters : 컴포넌트 스캔 대상을 추가로 지정
- excludeFilters : 컴포넌트 스캔에서 제외할 대상을 지정

위와 같이 컴포넌트 스캔을 위한 여러 설정을 하고나면, ComponentScanAnnotationParser가 컴포넌트 후보를 모두 찾아 스캔하기 위하여 해당 설정을 파싱하여 가져온다.
설정을 바탕으로 ClassLoader를 이용하여 모든 클래스를 로딩하고, 로딩한 클래스를 BeanDefinition으로 정의한다. 이후, 설정한 빈 정의를 바탕으로 빈을 생성한다.


### 참고
- 자바의 정석 3판
- https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8
- https://jess-m.tistory.com/14

## 단위 테스트와 통합 테스트 탐구

### 단위 테스트와 통합 테스트의 의미를 알아봅시다!
#### 단위 테스트
하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 단위의 테스트를 단위 테스트라고 한다. 이때, 모듈은 애플리케이션에서 작동하는 하나의 기능 또는 메서드로 볼 수 있다. (ex. 로그인 메서드에 대한 독립적인 테스트)

즉, 단위 테스트는 프로그램의 각 부분을 고립시켜 각각의 부분이 정확하게 동작하는지의 여부를 확인할 수 있다. 그렇기 때문에 에러 발생 시 어느 부분이 잘못되었는지를 빠르게 찾을 수 있다.

#### 통합 테스트
모듈을 통합하는 과정에서 모듈 간의 호환성을 확인하기 위해 수행되는 테스트를 통합 테스트라고 한다. 실제 프로그램 상에서 각각의 모듈은 개별적으로 존재하는 것이 아니라 서로 유기적 관계를 맺는다. 따라서 통합 테스트를 통해 모듈 간의 상호작용이 정상적으로 수행되는지의 여부를 확인한다.

### 스터디 자료의 단위 테스트 예제는 엄밀한 의미의 단위 테스트라고 부를 수 있을까요? 아니라면 엄밀한 의미의 단위 테스트로 구현하기 위해 어떻게 바꾸어야 할지 생각해 보아요.

단위 테스트 예제에서의 controller는 service 단의 코드가 따로 존재하지 않고, controller에서 곧장 string을 반환한다. 지금의 코드는 간단한 string을 반환하기 때문에 크게 문제가 되지는 않겠지만, 나라면 service 단의 코드를 분리하여 따로 작성하고 controller 부분을 테스트해보기 전에 service 부분이 올바르게 동작하는지의 여부를 먼저 테스트해볼 것 같다.

### 참고
- https://mangkyu.tistory.com/143
- https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%9B_%ED%85%8C%EC%8A%A4%ED%8A%B8
- https://support.suresofttech.com/ko/support/solutions/articles/5000760844-%ED%86%B5%ED%95%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94-
